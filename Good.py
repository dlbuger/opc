{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Name: opcda_to_opcua.py\n",
    "#\n",
    "# Description:\n",
    "# Proxy between OPC-DA server and OPC-UA client.\n",
    "# Firstly the OPC-DA namespace is traversed using a recursive\n",
    "# function. These variables are then classified as readable or writable\n",
    "# and added to the OPC-UA namespace. The readable variables are read\n",
    "# periodically from the OPC-DA server and published on the OPC-UA server.\n",
    "# The writable OPC-UA tags are monitored for changes. When a change is\n",
    "# caught then the new value is published to the OPC-DA server.\n",
    "#\n",
    "# The code is organized as follows:\n",
    "# 1. Configuration\n",
    "# 2. Connec to OPC-DA server\n",
    "# 3. Discover OPC-DA server nodes\n",
    "# 4. Subscribe to datachanges coming from OPC-UA clients\n",
    "# 5. Read all readables simultaneously and update the OPC-UA variables\n",
    "#    to reflect the OPC-DA readings\n",
    "\n",
    "# Requires Anaconda, OpenOPC\n",
    "# L 609 in address_space.py, python-opcua v 0.90.3\n",
    "\n",
    "import logging, time, sys, decimal, OpenOPC\n",
    "from datetime import datetime\n",
    "from opcua import ua, uamethod, Server\n",
    "\n",
    "logging.basicConfig()\n",
    "reload(sys)\n",
    "sys.setdefaultencoding('utf-8') \n",
    "## 1. Configuration\n",
    "OPC_DA_SERVER = 'Intellution.IntellutionGatewayOPCServer'\n",
    "OPC_UA_CERTIFICATE = 'C:\\Users\\BUGER\\AppData\\Roaming\\unifiedautomation\\uaexpert\\PKI\\own\\certs\\uaexpert.der'\n",
    "OPC_UA_PRIVATE_KEY = 'C:\\Users\\BUGER\\AppData\\Roaming\\unifiedautomation\\uaexpert\\PKI\\own\\private\\uaexpert_key.pemm'\n",
    "OPC_UA_URI = 'urn:freeopcua:python:server'\n",
    "\n",
    "# Constants\n",
    "ITEM_ID_VIRTUAL_PROPERTY = 0\n",
    "ITEM_CANONICAL_DATATYPE = 1\n",
    "ITEM_VALUE = 2\n",
    "ITEM_QUALITY = 3\n",
    "ITEM_TIMESTAMP = 4\n",
    "ITEM_ACCESS_RIGHTS = 5\n",
    "SERVER_SCAN_RATE = 6\n",
    "ITEM_EU_TYPE = 7\n",
    "ITEM_EU_INFO = 8\n",
    "ITEM_DESCRIPTION = 101\n",
    "ACCESS_READ = 0\n",
    "ACCESS_WRITE = 1\n",
    "ACCESS_READ_WRITE = 2\n",
    "\n",
    "# Set up server\n",
    "server = Server()\n",
    "server.set_endpoint('opc.tcp://192.168.2.32:48400/freeopcua/server/')\n",
    "#server.load_certificate(OPC_UA_CERTIFICATE)\n",
    "#server.load_private_key(OPC_UA_PRIVATE_KEY)\n",
    "uri = OPC_UA_URI\n",
    "idx = server.register_namespace(uri)\n",
    "root = server.nodes.objects.add_object(idx, OPC_DA_SERVER)\n",
    "\n",
    "## 2. Connect to OPC-DA server\n",
    "c = OpenOPC.client()\n",
    "# List OPC-DA servers\n",
    "#servers = c.servers()\n",
    "c.connect(OPC_DA_SERVER)\n",
    "\n",
    "class SubscriptionHandler(object):\n",
    "\tdef __init__(self,n):\n",
    "\t\tself.i = 0\n",
    "\t\tself.n = n\n",
    "\tdef final_datachange_notification(self, node, val, data):\n",
    "\t\tpath_as_string = node.get_path_as_string()\n",
    "\t\t# 'path_as_string' is a list of strings containing:\n",
    "\t\t# 0: 0:Root\n",
    "\t\t# 1: 1:Objects\n",
    "\t\t# 2: 2:OPC DA Server\n",
    "\t\t# 3 and onwards: 3:[Step of path to node in OPC-DA]\n",
    "\t\topc_da_address = '.'.join([a.split(':')[1] for a in path_as_string[3:]])\n",
    "\t\tcc = OpenOPC.client()\n",
    "\t\tcc.connect(OPC_DA_SERVER)\n",
    "\t\tprint('Datachange', opc_da_address, val, cc.write((opc_da_address, val,)))\n",
    "\t\tcc.close()\n",
    "\t# This function is called initially to catch the notifications from newly added nodes\n",
    "\tdef datachange_notification(self, node, val, data):\n",
    "\t\tself.i = self.i + 1\n",
    "\t\t#print('Catching meaningless datachange notification')\n",
    "\t\tif self.i == self.n:\n",
    "\t\t\t#print('Finished catching meaningless datachange notifications')\n",
    "\t\t\tself.datachange_notification = self.final_datachange_notification\n",
    "\n",
    "def read_value(value):\n",
    "\tvalue = value[0]\n",
    "\tif isinstance(value,decimal.Decimal):\n",
    "\t\tvalue = float(value)\n",
    "\telif isinstance(value,list):\n",
    "\t\tif len(value) == 0:\n",
    "\t\t\tvalue = None\n",
    "\telif isinstance(value,tuple):\n",
    "\t\tif len(value) == 0:\n",
    "\t\t\tvalue = None\n",
    "\treturn value\n",
    "\n",
    "## 3. Discover OPC-DA server nodes\n",
    "readable_variable_handles = {}\n",
    "writeable_variable_handles = {}\n",
    "nodes = c.list('*',recursive=True)\n",
    "# 'nodes' is a list of dot-delimited strings.\n",
    "tree = {}\n",
    "#nodes.remove(u'Bucket Brigade.Time')\n",
    "#nodes.remove(u'Random.Time')\n",
    "#nodes.remove(u'Write Error.Time')\n",
    "#nodes.remove(u'Write Only.Time')\n",
    "for node in nodes:\n",
    "\tparts = node.split('.')\n",
    "\t# Folders are the steps on the path to the file.\n",
    "\tfolders = parts[:-1]\n",
    "\tfile = parts[-1]\n",
    "\t# Create folder tree if it does not already exist\n",
    "\tfor i, folder in enumerate(folders,1):\n",
    "\t\tif i == 1:\n",
    "\t\t\tparent = root\n",
    "\t\telse:\n",
    "\t\t\tparent = tree[path]\n",
    "\t\tpath = '.'.join(folders[0:i])\n",
    "\t\tif path not in tree.keys():\n",
    "\t\t\ttree[path] = parent.add_folder(idx,folder.encode('utf-8'))\n",
    "\t# 'path' is now the folder that file resides in.\n",
    "\t# Determine node properties\n",
    "\tnode_obj = {}\n",
    "\tfor id, description_of_id, value in c.properties(node):\n",
    "\t\tif id is ITEM_ACCESS_RIGHTS:\n",
    "\t\t\tif value == 'Read':\n",
    "\t\t\t\tvalue = ACCESS_READ\n",
    "\t\t\telif value == 'Write':\n",
    "\t\t\t\tvalue = ACCESS_WRITE\n",
    "\t\t\telif value == 'Read/Write':\n",
    "\t\t\t\tvalue = ACCESS_READ_WRITE\n",
    "\t\tnode_obj[id] = value\n",
    "\tcurrent_value = read_value((node_obj[ITEM_VALUE],))\n",
    "\tif type(current_value) != int:\n",
    "\t\tcurrent_value = 0\n",
    "\t#print('Adding node '+file+' at path '+path)\n",
    "\topcua_node = tree[path].add_variable(idx, file.encode('utf-8'), ua.Variant(current_value, ua.VariantType.UInt16))\n",
    "\t# Determine readable vs. writable\n",
    "\tif node_obj[ITEM_ACCESS_RIGHTS] in [ACCESS_READ]:\n",
    "\t\treadable_variable_handles[node] = opcua_node\n",
    "\tif node_obj[ITEM_ACCESS_RIGHTS] in [ACCESS_WRITE, ACCESS_READ_WRITE]:\n",
    "\t\topcua_node.set_writable()\n",
    "\t\twriteable_variable_handles[node] = opcua_node\n",
    "\n",
    "try:\n",
    "\tserver.start()\n",
    "\t## 4. Subscribe to datachanges coming from OPC-UA clients\n",
    "\thandler = SubscriptionHandler(len(writeable_variable_handles))\n",
    "\tsub = server.create_subscription(100, handler).subscribe_data_change(writeable_variable_handles.values())\n",
    "\treadables = list(readable_variable_handles.keys())\n",
    "\twhile True:\n",
    "\t\ttime.sleep(0.5)\n",
    "\t\t## 5. Read all readables simultaneously and update the OPC-UA variables\n",
    "\t\tfor reading in c.read(readables):\n",
    "\t\t\topc_da_id = reading[0]\n",
    "\t\t\tvariable_handle = readable_variable_handles[opc_da_id]\n",
    "\t\t\tvariable_handle.set_value(read_value(reading[1:]))\n",
    "finally:\n",
    "\tserver.stop()\n",
    "\tc.close()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.15"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
